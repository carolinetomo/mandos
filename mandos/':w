from tree_utils2 import * 
import tree_reader2
from scipy import optimize
import math
from numpy import random
import sys
import tree_utils2

cdef double LARGE = 1000000000.0

cpdef double bm_prune(object tree, dict traits):
    cdef:
        double like,charst
        unsigned int mat_len,site
        object node
        str val
    mat_len = len(traits.values()[0])
    for site in range(mat_len):
        if site != 1: 
            continue
        for node in tree.iternodes():
            print tree.get_newick_repr()
            if node.label == "Ampelocissus_abyssinica":
                print node.label,node.istip
            if node.istip:
                val = traits[node.label][site]
                print node.label,val
                if val == "?" or val == "-":
                    tree_utils2.prune_node(tree,node)
                    continue
                charst = float(val)
                node.charst = charst
            node.old_length = node.length
        print tree.get_newick_repr(True)
        #like = c_bm_prune(tree)
        for j in tree.iternodes():
            j.length = j.old_length
    return like

cdef double c_bm_prune(object tree, double sigsq = 1.0):
    cdef:
        double contrast,cur_var,curlike,temp_charst,temp_brlen
        double node_likes = 0.0
        list child_charst 
        unsigned int i
        object j
    for j in tree.iternodes(order=1):
        if j.istip == False and j != tree:
            child_charst = [k.charst for k in j.children]
            brlens = [k.length for k in j.children]
            contrast = child_charst[0]-child_charst[1]
            cur_var = brlens[0]+brlens[1]
            curlike =((-0.5)* ((math.log(2*math.pi*sigsq))+(math.log(cur_var))+(math.pow(contrast,2)/(sigsq*cur_var))))
            node_likes += curlike
            #temp_charst = (((1/brlens[0])*child_charst[0])+((1/brlens[1])*child_charst[1]))/((1/brlens[0])+(1/brlens[1]))
            temp_charst = ((brlens[1]*child_charst[0])+(brlens[0]*child_charst[1]))/(sum(brlens))
            temp_brlen = j.length+((brlens[0]*brlens[1])/(brlens[0]+brlens[1]))
            j.charst = temp_charst
            j.length = temp_brlen
        elif j == tree:
            child_charst = [k.charst for k in j.children]
            brlens = [k.length for k in j.children]
            contrast = child_charst[0]-child_charst[1]
            cur_var = brlens[0]+brlens[1]
            curlike =((-0.5)* ((math.log(2*math.pi*sigsq))+(math.log(cur_var))+(math.pow(contrast,2)/(sigsq*cur_var))))
            node_likes += curlike
    #trait_likes += node_likes
    return node_likes

cpdef double sigsqML(object tree): #tree must already have characters mapped to tips using match_traits_tips()
    cdef:
        unsigned int n,p
        list vals,x,t
        double ui,Vi,add,div,sig2
    n = len(tree.leaves())
    vals = [None]*(n-2)
    p = 0
    for i in tree.iternodes(order=1):
        if i.istip == False and i != tree:
            x = [j.charst for j in i.children]
            t = [j.length for j in i.children]
            ui = abs(x[0]-x[1])
            Vi = sum(t)
            vals[p] = (ui,Vi)
            add = (t[0]*t[1])/(t[0]+t[1])
            i.length = i.length + add
            p += 1
        if i == tree:
            t = [j.length for j in i.children]
            Vi = sum(t)
            V0 = (t[0]*t[1])/(t[0]+t[1])
    div = sum([math.pow(i[0],2)/i[1] for i in vals])+(0/V0)
    sig2 = (1./n) * div
    return sig2
