import tree_reader2,tree_utils2
import tree_likelihood_calculator as tlc
import stratoML
from copy import deepcopy
import sys
import math

"""
these gives branch support values that approximate the posterior probability using the aBayes approach
citation: Anisimova et al., 2011, implemented in PhyML
"""


#TODO: this should read in tree and all data and map approximated posteriors to each node
def aBayes(tree,alignment,partitions,stratigraphy):
    seqs = tree_utils2.read_phylip_file(alignment)
    sitels = tree_utils2.read_partition_file(partitions)

    for node in nt.iternodes():
        nt = deepcopy(tree)
        if node.istip == True or len(node.descendants()) < 3 or node == nt:
            continue
        
        approx_node_PP(nt,node,seqs,sitels,strat)



def approx_node_PP(tree,node, seqs, sitels, stratigraphy): #TODO: need to optimise branch lengths
    dist = tree_utils2.nni_set(node,tree)#.nni_set()
    bipart_likes = []
    for bipart in dist:
        cur_nni = tree_reader2.read_tree_string(bipart)
        stratigraphic_likelihood = stratoML.optim_lambda_heights(cur_nni,stratigraphy)
        partition_likelihoods = []
        for i in range(len(sitels)):
            cursites = sitels[i]
            cur_start = cur_sites[0]-1
            cur_end = cur_sites[1]-1
            if i+1 == 1:
                continue
            tlc.match_tips_and_seqs(cur_nni,seqs)
            rmatrix,basefreq = set_multi_jc_rmatrix_basefreq(i+1)
            curcost = tlc.calc_mult_tree_likelihood(cur_nni,rmatrix,basefreq,range(cur_start,cur_end),False)
            partition_likelihoods.append(curcost)
        MK_likelihood = sum(partition_likelihoods)
        total_likelihood = MK_likelihood+stratigraphic_likelihood
        if bipart.get_newick_repr() == node.get_newick_repr():
            node_like = total_likelihood
        bipart_likes.append(total_likelihood)
    marginal_like = logsum(bipart_likes) 
    PP = node_like - marginal_like
    return PP

def read_treeset_likelihoood_file(like_fl):
    tree_liks = {}
    for i in open(like_fl,"r"):
        spls = i.strip().split("\t")
        if len(spls) != 2:
            print "Input trees and likelihoods are in the wrong format. \n\n They should be like:\n\n"
            print "-2000\t(c,(a,b))\n"
            print "(so one per line, with loglikelihoods and newicks tab separated)"
            sys.exit(0)
        cur_tree = spls[1]
        tree_struct = tree_reader2.read_tree_string(cur_tree)
        nwk = tree_struct.get_newick_repr()+";" # write the tree without any brlens
        cur_lik = spls[0]#.split("lh=")[1].strip()
        #tree_array = tuple([(node.parent,node) for node in tree_struct.iternodes()]) #store tree as array to look up later
        tree_liks[nwk] = cur_lik
    return tree_liks

"""
this calculates approx node PPs using likelihoods generated by iqtree 
during stratoclad tree search
"""
def aBayes_precalc_output(tree,like_fl,stratfl):
    strat = tree_utils2.read_strat(stratfl)
    #tree = deepcopy(tree)
    #tree_utils2.get_all_tree_NNIs(tree)
    #sys.exit(0)
    print "reading in tree_set and precalculated likelihoods"
    tree_liks = read_treeset_likelihoood_file(like_fl)
    """
    print "calculating stratigraphic likelhood of input tree"
    tree_utils2.match_strat(tree,strat)
    tree_utils2.init_heights_strat(tree)
    stratolike = -stratoML.optim_lambda(tree,strat)[1][1]
    tree_tup = tuple([(node.parent,node) for node in tree.iternodes()])
    morpholike = float(tree_liks[tree.get_newick_repr()+";"])
    morpholike +stratolike
    t1_like = stratolike+morpholike
    """
    nt = deepcopy(tree)
    #map_nodes = {}
    #nt_array = [i for i in nt.iternodes()]
    #tree_array = [i for i in tree.iternodes()]
    #for i in range(len(tree_array)):
    #    map_nodes[nt_array[i]] = tree_array[i]
    PP_list = []
    PP_dic = {}
    for node in nt.iternodes(): #go though and make 3 NNIs for each node and comparing all likelihoods
        if node.istip or len(node.descendants()) < 3 or node == nt:
            continue
        distr = tree_utils2.nni_set(node,nt)#.nni_set()
        likes = []
        for config in distr:
            #if config == tree.get_newick_repr():
            #    continue
            config += ";"
            cur_nni = tree_reader2.read_tree_string(config)
            tree_utils2.match_strat(cur_nni,strat)
            tree_utils2.init_heights_strat(cur_nni,strat)
            stratolike = -stratoML.optim_lambda_heights(cur_nni,strat)[1][1]
            #tree_array = tuple([(node.parent,node) for node in cur_nni.iternodes()])
            morpholike = tree_liks[config]
            loglike = stratolike + float(morpholike)
            likes.append(loglike)
            #if loglike > t1_like:
            #    print loglike,config
        #likes.append(t1_like)
        """
        print "\n\n"
        print [i.label for i in node.leaves()]
        print "\n\n"
        """
        t1_like = max(likes)
        marg = logsum(likes)
        PP = math.exp(t1_like-marg)
        PP_list.append(PP)
    count = 0
    for node in nt.iternodes():
        if node.istip or len(node.descendants()) < 3 or node == nt:
            continue
        node.label = str(PP_list[count])
        count += 1

    """
    count = 0
    for node in tree.iternodes():
        if node.istip or len(node.descendants()) < 3 or node == tree:
            continue
        node.label = PP_list[count]
        #print [i.label for i in node.leaves()]
        count +=1
        break
    #print [i.label for i in nt.iternodes()]
    """
    return nt.get_newick_repr(True)


def logsum(l):
    x = l[0]
    for i in l[1:]:
        try:
            x += math.log1p(math.exp(i-x))
        except:
            x += 0
    return x
